# â˜• UygulamanÄ±n Ã§alÄ±ÅŸabilmesi iÃ§in bir Java Ã§alÄ±ÅŸma ortamÄ± (JDK) gereklidir.
# Amazon Corretto 17, OpenJDKâ€™nÄ±n gÃ¼venli ve AWS tarafÄ±ndan optimize edilmiÅŸ sÃ¼rÃ¼mÃ¼dÃ¼r;
# bu sayede hem lisans aÃ§Ä±sÄ±ndan sorun yaÅŸamam, hem de kararlÄ± bir JVM ortamÄ± elde ederim. ğŸ’ª
FROM amazoncorretto:17

# ğŸ’¡ Alternatif olarak OpenJDK 17 kullanÄ±labilir; ancak Corretto, kurumsal projelerde uzun vadeli destek (LTS) avantajÄ± saÄŸlar.
# FROM openjdk:17

# ğŸ“¦ Bu satÄ±rda, projemde derleme sonrasÄ± oluÅŸan JAR dosyasÄ±nÄ±n yolunu tanÄ±mlÄ±yorum.
# `ARG` ifadesi, JAR ismini sabitlemek yerine dinamik olarak belirlememi saÄŸlar;
# yani hangi isimle JAR Ã¼retirsem Ã¼retim, Docker bunu otomatik olarak bulup kopyalayabilir. ğŸ§©
ARG JAR_FILE=target/*.jar

# ğŸšš Bu komut, belirtilen JAR dosyasÄ±nÄ± Docker imajÄ±nÄ±n iÃ§ine kopyalar.
# ArtÄ±k projemin Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyasÄ± konteynerin iÃ§inde â€œapplication.jarâ€ adÄ±yla yer alÄ±r.
# BÃ¶ylece uygulamayÄ± dÄ±ÅŸ dÃ¼nyadan tamamen izole biÃ§imde Ã§alÄ±ÅŸtÄ±rabilirim. ğŸ”’
COPY ${JAR_FILE} application.jar

# ğŸŒ Docker konteynerinin dÄ±ÅŸ dÃ¼nyayla iletiÅŸim kuracaÄŸÄ± portu aÃ§Ä±yorum.
# Spring Boot varsayÄ±lan olarak 8080 portunu dinler, bu yÃ¼zden burada da o portu expose ederim.
# BÃ¶ylece dÄ±ÅŸ kullanÄ±cÄ±lar veya servisler, uygulamama HTTP Ã¼zerinden eriÅŸebilir. ğŸ“¡
EXPOSE 8080

# ğŸš€ Bu satÄ±r, Docker konteyneri Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda hangi komutun otomatik olarak baÅŸlatÄ±lacaÄŸÄ±nÄ± belirtir.
# â€œjava -jar application.jarâ€ komutu, JAR dosyamÄ± JVM Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±r ve uygulamamÄ± canlÄ± hale getirir.
# ENTRYPOINT komutu sayesinde, konteyner kapanÄ±rsa uygulama da durur â€” sistemsel bÃ¼tÃ¼nlÃ¼k korunur. âš™ï¸
ENTRYPOINT ["java","-jar","application.jar"]